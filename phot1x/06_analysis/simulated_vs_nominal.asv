%% User inputs
dL = 219.366; % um
data_name = 'Phot1x-DataSets/DataSet1/ZiheGao_MZI17_265_Scan1.mat';
loopback_name = 'Phot1x-DataSets/DataSet1/ZiheGao_MZI1_272_Scan1.mat';
% loopback_name = 'Phot1x-DataSets/DataSet1/ZiheGao_MZI17_265_Scan1.mat';

PORT=1; % Which Fibre array port is the output connected to?

% Compact model for 500nm x 220nm waveguide using Lumerical MODE
simulated_n = [2.4489, -1.1337, -0.0451];

% Set up loading corner analysis data
corner_file_dir = 'C:\Users\chris\Documents\GitHub\si-photonics\phot1x\05_fabrication\corner_analysis';
corner_file_names = {'wg_2D_sweep_wl_width=470nm,thick=215.3nm.mat',
                     'wg_2D_sweep_wl_width=470nm,thick=223.1nm.mat',
                     'wg_2D_sweep_wl_width=510nm,thick=215.3nm.mat',
                     'wg_2D_sweep_wl_width=510nm,thick=223.1nm.mat'};
          
corner_legend_names = {'width=470nm,thick=215.3nm',
                       'width=470nm,thick=223.1nm',
                       'width=510nm,thick=215.3nm',
                       'width=510nm,thick=223.1nm'};

% 'width=470nm; thickness=215.3nm; fsr = 5.68nm; neff = 2.3714; ng = 4.229; 
% [2.3714, -1.1986, -0.031674]

%'width=470nm; thickness=223.1nm; fsr = 5.665nm; neff = 2.399; ng = 4.2372; 
% [2.399, -1.1861, -0.048276]

% 'width=510nm; thickness=215.3nm; fsr = 5.7733nm; neff = 2.439; ng = 4.1588; 
% [2.439, -1.1095, -0.027541]

% 'width=510nm; thickness=223.1nm; fsr = 5.77nm; neff = 2.4664; ng = 4.1656; 
% [2.4664, -1.0963, -0.040006]

% 'width=500nm; thickness=220nm; fsr = 5.7533nm; neff = 2.4423; ng = 4.177; 
% [2.4423, -1.1192, -0.037436]

% Fit to the data in this range. Make sure you have loopback data in this
% range!!
lambda_min = 1.521e-6;
lambda_max = 1.569e-6;
% lambda0 = 1.545;

%% Use the loopback data to subtract the background due non-device effects
% These include the bandwidth of the GCs, waveguide loss, bending loss, etc

load(loopback_name);
lambda_loopback = scanResults(1,PORT).Data(:,1)/1e9;
amplitude_loopback = scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
bkgd_center = mean(lambda_loopback);
p_bkgd=polyfit((lambda_loopback - bkgd_center)*1e6, amplitude_loopback, 4);

% If the calibration file is another MZI, the above fit will be through the 
% middle of the transmission profile, but the baseline we want to correct
% is the overall envelope, which is the fit to the maximum of the fringes.
% One way to do this is to adjust the baseline to account for the
% difference between this fit baseline and the maximum of the fringes
% Uncomment the lines below to do this

% amplitude_baseline=polyval(p_bkgd,(lambda_loopback - bkgd_center)*1e6); 
% extra_offset = max(amplitude_baseline) - max(amplitude_loopback);
% p_bkgd(end) = p_bkgd(end) - extra_offset;

%% Background subtract the data
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
load(data_name);
lambda_raw=scanResults(1,PORT).Data(:,1)/1e9;
amplitude_raw=scanResults(1,PORT).Data(:,2);
amplitude_baseline = polyval(p_bkgd,(lambda_raw - bkgd_center)*1e6); 
amplitude_corrected = amplitude_raw - amplitude_baseline;

lambda_fit=lambda_min:min(diff(lambda_raw)):lambda_max;

% For some reason, the suggested approach here is to interpolate the 
% data in order to fit it. This seems very wrong
amplitude_fit = interp1(lambda_raw, amplitude_corrected, lambda_fit,'linear');
% check if there are -infinity data points
amplitude_fit(find(amplitude_fit==-inf))=-50;

%% Plot simulation vs. experiment

lambda0 = mean(lambda_fit)*1e6;
% MZI transfer function, holding constant the values for lambda0 and dL
fit_T_MZI = @(X, lambda) ...
            T_MZI(lambda0, dL, X, lambda);
% Background correction means no losses, X(4) (=alpha) = 0 and X(5) = 0
x0 = [simulated_n, 0, 0] ;

figure;
hold on

plot(lambda_raw*1e6, amplitude_raw, 'DisplayName', 'Raw data');
plot(lambda_loopback*1e6, amplitude_loopback, 'DisplayName', 'Loopback');
plot(lambda_fit*1e6, amplitude_fit, 'DisplayName', 'Baseline corrected');
plot(lambda_fit*1e6, fit_T_MZI(x0, lambda_fit*1e6), 'DisplayName', 'Simulation');

xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
legend('Location', 'southwest')
title (join(['MZI with \DeltaL = ', num2str(dL), '\mum']));
xlim([lambda_min*1e6, lambda_max*1e6])

%% Generate inital guess for the fit

nx_init = [2.5, -1, 0];
% nx_init = simulated_n;

alpha_init = 1e-3;  % propagation loss [micron^-1]
device_loss = 0;

%% Fit the data

x0=[nx_init, alpha_init, device_loss];

[xfit,resnorm] = lsqcurvefit(fit_T_MZI, x0, lambda_fit*1e6, amplitude_fit);
% xfit
r=corrcoef(amplitude_fit, fit_T_MZI(xfit, lambda_fit * 1e6));
r2=r(1,2).^2

%% Plot fit vs experiment

figure;
hold on

%plot(lambda_raw*1e6, amplitude_raw, 'DisplayName', 'Raw data');
%plot(lambda_loopback*1e6, amplitude_loopback, 'DisplayName', 'Loopback');
plot(lambda_fit*1e6, amplitude_fit, 'DisplayName', 'Baseline corrected');
plot(lambda_fit*1e6, fit_T_MZI(xfit, lambda_fit*1e6), 'DisplayName', 'Fit');

xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
legend('Location', 'southwest')
title (join(['MZI with \DeltaL = ', num2str(dL), '\mum']));
xlim([lambda_min*1e6, lambda_max*1e6])


%% Extract ng and plot vs. theory

neff_fit = neff(lambda0, xfit(1:3), lambda*1e6);
ng_fit = ng_func(neff_fit, lambda*1e6);
neff_sim = neff(lambda0, simulated_n, lambda*1e6);
ng_sim = ng_func(neff_sim, lambda*1e6);

figure;
hold on

plot(lambda*1e6, ng_fit, 'DisplayName', 'Fit')
plot(lambda*1e6, ng_sim, 'DisplayName', 'Simulated wg (220nm x 500nm)')

legend()
xlabel('Wavelength [\mum]')
ylabel('Group index')

%% Some useful functions

% effective index:
function n = neff(lambda0, nx, lambda)
    n = (nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2);
end

% complex propagation constant
function b = beta(lambda0, nx, alpha, lambda)
    % nx: the n1, n2, n3 parameters for the waveguide compact model
    % alpha: the waveguide attenuation coefficient in 1/um
    % lambda: List of wavelengths (in um)
    % lambda0: Center wavelength for the waveguide compact model (in um)
    n = neff(lambda0, nx, lambda);
    b = (2*pi*n./lambda - 1i*alpha/2*ones(1,length(lambda)));
end

% MZI transfer function
function t = T_MZI(lambda0, dL, X, lambda)
    % lambda0: Center wavelength for the waveguide compact model (in um)
    % dL: The MZI length imbalance (in um)
    % X(1:3): the n1, n2, n3 parameters for the waveguide compact model
    % X(4): the waveguide attenuation coefficient ("alpha") in 1/um
    % X(5): the wavelength-independent loss in the device (in dB).
    % lambda: List of wavelengths (in um)

    b = beta(lambda0, X(1:3), X(4), lambda);
    t = (10*log10( 0.25* abs(1+exp(-1i*b*dL)).^2) +X(5) );
end

% Group index, from finite differences of the effective index
function ng_arr = ng_func(neff, lambda)
    % lambda: array of wavelengths
    % neff: array of effective indices evaluated at each wavelength
    dndlambda = diff(neff) ./ diff(lambda); 
    dndlambda = [dndlambda, dndlambda(end)]; % Make derivative same size
    ng_arr = (neff - lambda .* dndlambda);
end
